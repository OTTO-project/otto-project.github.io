{"componentChunkName":"component---src-templates-doc-js","path":"/docs/dsp/1overview","webpackCompilationHash":"d2c9714aa9ee603d5aa5","result":{"data":{"doc":{"id":"63075b4e-5e93-51fb-b618-64f5b131b9f2","title":"DSP Overview","description":null,"excerpt":"DSP Overview DSP for the synthesizer and effects engines for OTTO is mainly done in  Gamma , a C++ library for DSP. Hand-writing DSP code isâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"dsp-overview\"\n  }, \"DSP Overview\"), mdx(\"p\", null, \"DSP for the synthesizer and effects engines for OTTO is mainly done in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/LancePutnam/Gamma\"\n  }), \"Gamma\"), \", a C++ library for DSP. Hand-writing DSP code is of course always welcome. If you have other C++ libraries you would like to use, please let us know on the discord server. \"), mdx(\"p\", null, \"There are two main signal paths in OTTO, which run parallel to each other:\"), mdx(\"p\", null, \"The \\\"Drum path\\\": \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sequencer -> Samplers\")), mdx(\"p\", null, \"The \\\"Synth path\\\": \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Arpeggiator -> Synthesizer\")), mdx(\"p\", null, \"Furthermore, there are two audio effect slots, that both paths can send to. The external input can also send to these.\"), mdx(\"p\", null, \"The \\\"Drum Path\\\" is still a work-in-progress, so for now we will focus on the \\\"Synth Path\\\" and audio effects.\"), mdx(\"h2\", {\n    \"id\": \"arpeggiators\"\n  }, \"Arpeggiators\"), mdx(\"p\", null, \"These take MIDI input and transform it in some way. This might be as a standard arpeggiator, but it could also be as a chord bank or randomizer or something completely different. Think \\\"MIDI Effects\\\" from Ableton Live.\\nThey can optionally be bypassed so they just send the unaltered MIDI signal through.\"), mdx(\"h2\", {\n    \"id\": \"synthesizers\"\n  }, \"Synthesizers\"), mdx(\"p\", null, \"Synthesizers take MIDI input and output \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mono\"), \" audio. They are controlled by our voice allocator, so a synthesizer is defined by defining a single voice of it, which must run independently from the other voices. Of course, it is also possible to do preprocessing for all the voices and post-processing of the summed output of the voices.\\nIn general, the only constraint is that individual voices must controlled by the voice allocator. It is possible to do this where each voice is calculated per-sample, of for a full buffer at a time. See the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Goss\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OTTO.FM\"), \" synth for examples.\"), mdx(\"h2\", {\n    \"id\": \"audio-effects\"\n  }, \"Audio effects\"), mdx(\"p\", null, \"Audio effects take a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mono\"), \" input and returns a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stereo\"), \" output. How much audio signal they get from different elements of OTTO is determined by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sends\"), \" that is owned by the corresponding element.\"), mdx(\"h3\", {\n    \"id\": \"sends\"\n  }, \"Sends\"), mdx(\"p\", null, \"Every channel of audio (samplers, synthesizer, external input) goes through a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sends\"), \" object. This determines how much of the audio to send to audio effects 1 and 2, as well as the volume and pan of the dry signal.\\nDry signals and audio effects outputs are then summed and output from OTTO.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"DSP Overview"},{"value":"Arpeggiators"},{"value":"Synthesizers"},{"value":"Audio effects"},{"value":"Sends"}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"63075b4e-5e93-51fb-b618-64f5b131b9f2","slug":"/docs/dsp/1overview","prev":{"id":"1f6af0ac-207c-55dc-9075-f1698e0dd6c5","slug":"/docs/dsp/2engines"},"next":{"id":"3b062c48-b7cd-51a1-9dbc-5162aa19d56b","slug":"/docs/dev-guide"}}}}