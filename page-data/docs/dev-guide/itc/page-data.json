{"componentChunkName":"component---src-templates-doc-js","path":"/docs/dev-guide/itc","webpackCompilationHash":"428e95a641fe76872011","result":{"data":{"doc":{"id":"b621a31f-8e7f-526b-83bb-fd010fc3c434","title":"Inter-Thread Communication","description":null,"excerpt":"Inter-Thread Communication Actions Actions are at the center of the inter-thread communication model used in OTTO. The are the \"packagesâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"inter-thread-communication\"\n  }, \"Inter-Thread Communication\"), mdx(\"h2\", {\n    \"id\": \"actions\"\n  }, \"Actions\"), mdx(\"p\", null, \"Actions are at the center of the inter-thread communication model used in OTTO. The are the \\\"packages\\\" that are sent between threads.\"), mdx(\"p\", null, \"An action is defined as a type alias to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::Action<Tag, Args...>\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \" is a unique tag type per action, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Args...\"), \" is an arbitrary number of arguments passed with the action.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"struct Actions {\\n  /// Set the sample buffer.\\n  /// Sent whenever the sample buffer should change.\\n  /// @param buffer the location of the new sample data. Allocated from the audio pool.\\n  using set_sample_buffer = itc::Action<struct set_sample_action, gsl::span<float>>;\\n  //    ~~~~~~~ A ~~~~~~~               ~~~~~~~~~~~ B ~~~~~~~~~~  ~~~~~~~ C ~~~~~~\\n};\\n\")), mdx(\"p\", null, \"In the action defined above, the action has the name (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \") \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_sample_buffer\"), \". The unusual syntax at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" declares a tag type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_sample_action\"), \", which will never be defined. Since the tag type is only used to differentiate the action types, this type is never used for anything else\"), mdx(\"p\", null, \"User-defined actions are usually defined in an Actions struct in the engine namespace. \"), mdx(\"h2\", {\n    \"id\": \"action-receivers\"\n  }, \"Action Receivers\"), mdx(\"p\", null, \"Actions are received and handled by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"action receivers\"), \". These can be any class that specifies an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"action handler\"), \" for the given action. The most common examples of action receivers are the engine's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Audio\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Screen\"), \" objects. These receive information from the engine by receiving actions.\"), mdx(\"p\", null, \"One can check whether a class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" is an action receiver for the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" using the type trait \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::ActionReceiver::is<T, A>\"), \".\"), mdx(\"h2\", {\n    \"id\": \"action-handlers\"\n  }, \"Action handlers\"), mdx(\"p\", null, \"Specific actions are handled in the receivers by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"action handlers\"), \" (the terminology isn't terribly important). They are member functions of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"action receiver\"), \", which are called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \", and take the type of the action (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \") as the first parameter, and the actions arguments (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \") as the following parameters. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"void action(Actions::rotation_variable, std::atomic<float>& v) noexcept;\\n//          ~~~~~~~~~~~ A ~~~~~~~~~~~~  ~~~~~~~~~ B ~~~~~~~~~ \\nvoid action(itc::prop_change<&Props::leslie>, float l) noexcept;\\n//          ~~~~~~~~~~~~~~~~ D ~~~~~~~~~~~~~  ~~ B ~~\\n\")), mdx(\"p\", null, \"Action handlers should not be called directly, but can be called using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::call_receiver(ar, Action::data(args...))\"), \". This allows us to add other ways of defining action handlers in the future (for instance forwarding all actions to a subobject etc.). \"), mdx(\"h2\", {\n    \"id\": \"actionqueue\"\n  }, \"ActionQueue\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::ActionQueue\"), \" is a concrete class, which is in essence just a thread-safe queue of function objects, which can be pushed to by one thread and executed by another. It then has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"push\"), \" function to help enqueue a function that calls an action handler, but usually you don't need to interact with it.\"), mdx(\"p\", null, \"When using the framework, you will mostly notice two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionQueue\"), \"s, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"graphics queue\"), \" and the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"audio queue\"), \". The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"graphics queue\"), \" is executed at the start of each frame, and is available as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIManager::current().action_queue()\"), \". The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"audio_queue\"), \" is executed at the start of each buffer, and is available as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AudioManager::current().action_queue()\"), \".\"), mdx(\"p\", null, \"Once again, in normal use, you will not need to interact with the queues directly, but it is nice to know of their existence.\"), mdx(\"h2\", {\n    \"id\": \"actionsender\"\n  }, \"ActionSender\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionSender\"), \"s is how you send actions to be executed on a another thread, i.e., push them to an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionQueue\"), \". The most important thing to know, is that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionSender\"), \" needs to know the addresses of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionReceiver\"), \"s it sends to. This is because the actual lambda which invokes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"call_receiver\"), \" and calls the action handler, is constructed on the sender side, and is then pushed into the queue. This is first of all because the sending side is in our case the logic thread, which is where we have the most resources available, and secondly, it means we only have to do type erasure once, for the function. Also, this gives the sender the power to see whether the action receiver actually implements a handler, and then do nothing in case it doesn't.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::ActionSender<Ar...>\"), \" is a class template, which takes the receivers the sender sends actions to. Its constructor takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"queue\"), \", and then references to the receivers.\"), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActionSender\"), \"s are per queue, engines need a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphicsSndr\"), \" and an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AudioSndr\"), \". To avoid having to use these separately, they can be used as a single ActionSender, by joining them using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itc::JoinedActionSender\"), \". Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".push\"), \" on this, will call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".push\"), \" on each sender it is given.\"), mdx(\"h3\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// In otto::engines::some_synth in src/engines/synth/some_synth/some_synth.hpp\\n\\nstruct Screen;\\nusing GraphicsSndr = itc::ActionSender<Screen, voices::EnvelopeScreen>;\\n\\nstruct Audio;\\nusing AudioSndr = itc::ActionSender<Audio>;\\n\\nusing Sndr = itc::JoinedActionSender<GraphicsSndr, AudioSndr>;\\n\\nstruct Engine : core::engine::SynthEngine<Engine> {\\n  // ...\\nprivate:\\n  GraphicsSndr graphics_sndr_;\\n  AudioSndr audio_sndr_;\\n  Sndr sndr_ = {graphics_sndr_, audio_sndr_};\\n  // ...\\n};\\n\\n// Engine constructor, defined in some_synth.cpp file\\n\\nSynthEngine::SynthEngine()\\n  : screen(std::make_unique<Screen>()), \\n    envelope_screen(std::make_unique<voices::EnvelopeScreen>()),\\n    audio(std::make_unique<Audio>()),\\n    graphics_sndr_(services::UIManager::current().make_sndr(*screen, envelope_screen)),\\n    audio_sndr_(services::AudioManager::current().make_sndr(*audio))\\n{\\n  // Send an action using the sender\\n  sndr_.push(Actions::rotation_variable::data(rotation_));\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Inter-Thread Communication"},{"value":"Actions"},{"value":"Action Receivers"},{"value":"Action handlers"},{"value":"ActionQueue"},{"value":"ActionSender"},{"value":"Example"}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"b621a31f-8e7f-526b-83bb-fd010fc3c434","slug":"/docs/dev-guide/itc","prev":{"id":"3b062c48-b7cd-51a1-9dbc-5162aa19d56b","slug":"/docs/dev-guide"},"next":{"id":"72e4b63c-1328-5766-98a4-5bb48e6f529d","slug":"/docs/dev-guide/engines"}}}}